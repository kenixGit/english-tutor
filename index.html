<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>English Tutor | ÏòÅÏñ¥ ÌäúÌÑ∞</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    height: 100vh; height: 100dvh;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .screen { display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; padding: 20px; }
  .screen.active { display: flex; }

  /* Lock Screen */
  #lockScreen { gap: 24px; }
  .lock-icon { font-size: 64px; margin-bottom: 8px; }
  .lock-title { font-size: 20px; font-weight: 600; color: #fff; }
  .lock-subtitle { font-size: 13px; color: #888; margin-top: -12px; }
  .pin-dots { display: flex; gap: 12px; margin: 8px 0; }
  .pin-dot {
    width: 14px; height: 14px; border-radius: 50%;
    border: 2px solid #555; background: transparent;
    transition: all 0.2s;
  }
  .pin-dot.filled { background: #00c896; border-color: #00c896; }
  .pin-dot.error { border-color: #ff4757; background: #ff4757; }
  .numpad { display: grid; grid-template-columns: repeat(3, 72px); gap: 12px; }
  .numpad button {
    width: 72px; height: 72px; border-radius: 50%;
    border: 1.5px solid #444; background: rgba(255,255,255,0.05);
    color: #fff; font-size: 28px; font-weight: 300;
    cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
  }
  .numpad button:active { background: rgba(0,200,150,0.3); border-color: #00c896; transform: scale(0.93); }
  .numpad button.fn { font-size: 14px; border: none; background: transparent; color: #888; }
  .numpad button.fn:active { color: #fff; }

  /* Call Screen */
  #callScreen { gap: 16px; position: relative; }
  .tutor-avatar {
    width: 120px; height: 120px; border-radius: 50%;
    background: linear-gradient(135deg, #00c896, #00a67e);
    display: flex; align-items: center; justify-content: center;
    font-size: 56px; margin-bottom: 4px;
    box-shadow: 0 0 40px rgba(0,200,150,0.15);
  }
  .tutor-name { font-size: 22px; font-weight: 600; color: #fff; }
  .tutor-label { font-size: 13px; color: #888; }
  #callTimer { font-size: 40px; font-weight: 200; color: #fff; letter-spacing: 2px; font-variant-numeric: tabular-nums; }
  #statusText { font-size: 15px; color: #00c896; min-height: 22px; transition: all 0.3s; }
  #errorText { font-size: 13px; color: #ff4757; min-height: 18px; max-width: 90%; text-align: center; word-break: break-word; }

  .volume-bar-container {
    width: 200px; height: 6px; background: #2a2a4a; border-radius: 3px; overflow: hidden; margin: 4px 0;
  }
  #volumeBar { height: 100%; width: 0%; background: linear-gradient(90deg, #00c896, #00ffaa); border-radius: 3px; transition: width 0.1s; }

  .volume-slider-container {
    display: flex; align-items: center; gap: 10px; margin: 8px 0; width: 220px;
  }
  .volume-slider-container span { font-size: 18px; }
  #volumeSlider {
    -webkit-appearance: none; appearance: none;
    flex: 1; height: 6px; border-radius: 3px;
    background: #2a2a4a; outline: none;
  }
  #volumeSlider::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none;
    width: 22px; height: 22px; border-radius: 50%;
    background: #00c896; cursor: pointer;
    box-shadow: 0 0 8px rgba(0,200,150,0.4);
  }
  #volumeSlider::-moz-range-thumb {
    width: 22px; height: 22px; border-radius: 50%;
    background: #00c896; cursor: pointer; border: none;
  }

  .call-controls { display: flex; gap: 32px; margin-top: 20px; align-items: center; }
  #callBtn {
    width: 80px; height: 80px; border-radius: 50%; border: none;
    font-size: 36px; cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  #callBtn.idle { background: #00c896; color: #fff; box-shadow: 0 0 20px rgba(0,200,150,0.4); }
  #callBtn.idle:active { transform: scale(0.92); }
  #callBtn.connecting {
    background: #f39c12; color: #fff;
    animation: pulse-orange 1.2s infinite;
  }
  #callBtn.active {
    background: #ff4757; color: #fff;
    box-shadow: 0 0 25px rgba(255,71,87,0.5);
  }
  #callBtn.active:active { transform: scale(0.92); }

  @keyframes pulse-orange {
    0%, 100% { box-shadow: 0 0 10px rgba(243,156,18,0.4); }
    50% { box-shadow: 0 0 30px rgba(243,156,18,0.7); }
  }

  .speaking-indicator {
    display: none; gap: 3px; align-items: center; height: 30px;
  }
  .speaking-indicator.visible { display: flex; }
  .speaking-indicator .bar {
    width: 4px; border-radius: 2px; background: #00c896;
    animation: speak-bar 0.8s ease-in-out infinite;
  }
  .speaking-indicator .bar:nth-child(1) { height: 10px; animation-delay: 0s; }
  .speaking-indicator .bar:nth-child(2) { height: 20px; animation-delay: 0.15s; }
  .speaking-indicator .bar:nth-child(3) { height: 14px; animation-delay: 0.3s; }
  .speaking-indicator .bar:nth-child(4) { height: 24px; animation-delay: 0.1s; }
  .speaking-indicator .bar:nth-child(5) { height: 12px; animation-delay: 0.25s; }

  @keyframes speak-bar {
    0%, 100% { transform: scaleY(0.4); }
    50% { transform: scaleY(1); }
  }
</style>
</head>
<body>

<!-- Lock Screen -->
<div id="lockScreen" class="screen active">
  <div class="lock-icon">üîí</div>
  <div class="lock-title">English Tutor</div>
  <div class="lock-subtitle">ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî</div>
  <div class="pin-dots" id="pinDots">
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
  </div>
  <div class="numpad" id="numpad">
    <button onclick="pinInput('1')">1</button>
    <button onclick="pinInput('2')">2</button>
    <button onclick="pinInput('3')">3</button>
    <button onclick="pinInput('4')">4</button>
    <button onclick="pinInput('5')">5</button>
    <button onclick="pinInput('6')">6</button>
    <button onclick="pinInput('7')">7</button>
    <button onclick="pinInput('8')">8</button>
    <button onclick="pinInput('9')">9</button>
    <button class="fn"></button>
    <button onclick="pinInput('0')">0</button>
    <button class="fn" onclick="pinDelete()">‚å´</button>
  </div>
</div>

<!-- Call Screen -->
<div id="callScreen" class="screen">
  <div class="tutor-avatar">üéì</div>
  <div class="tutor-name">English Tutor</div>
  <div class="tutor-label">AI ÏòÅÏñ¥ ÌöåÌôî ÌäúÌÑ∞</div>
  <div id="callTimer">00:00</div>
  <div id="statusText">ÌÜµÌôî ÏãúÏûëÏùÑ ÌÉ≠ÌïòÏÑ∏Ïöî / Tap to start</div>
  <div id="errorText"></div>
  <div class="volume-bar-container"><div id="volumeBar"></div></div>
  <div class="volume-slider-container">
    <span>üîà</span>
    <input type="range" id="volumeSlider" min="0" max="100" value="80">
    <span>üîä</span>
  </div>
  <div class="speaking-indicator" id="speakingIndicator">
    <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
  </div>
  <div class="call-controls">
    <button id="callBtn" class="idle" onclick="toggleCall()">üéôÔ∏è</button>
  </div>
</div>

<script type="module">
import { GoogleGenAI } from 'https://esm.sh/@google/genai@1.40.0/web';

// === PIN Lock ===
const PIN_HASH = 'ed7841674a6a92708eed1416db6206916811b10d3375a571ce2eb7139457e98f';
let pinValue = '';

async function sha256(str) {
  const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function updateDots() {
  document.querySelectorAll('.pin-dot').forEach((d, i) => {
    d.classList.toggle('filled', i < pinValue.length);
    d.classList.remove('error');
  });
}

async function pinInput(n) {
  if (pinValue.length >= 6) return;
  pinValue += n;
  updateDots();
  if (pinValue.length === 6) {
    const hash = await sha256(pinValue);
    if (hash === PIN_HASH) {
      document.getElementById('lockScreen').classList.remove('active');
      document.getElementById('callScreen').classList.add('active');
    } else {
      document.querySelectorAll('.pin-dot').forEach(d => d.classList.add('error'));
      setTimeout(() => { pinValue = ''; updateDots(); }, 600);
    }
  }
}

function pinDelete() {
  if (pinValue.length > 0) { pinValue = pinValue.slice(0, -1); updateDots(); }
}

// Expose to global for onclick handlers
window.pinInput = pinInput;
window.pinDelete = pinDelete;

// === Gemini Live API via Google GenAI SDK ===
const API_KEY = 'AIzaSyBkCiTO3ZAmqU2nyE9lRVgOvnDcKl8MfoA';
const ai = new GoogleGenAI({ apiKey: API_KEY });

let session = null;
let state = 'idle'; // idle | connecting | active
let micStream = null;
let micContext = null;
let micWorklet = null;
let playContext = null;
let gainNode = null;
let timerInterval = null;
let callStart = 0;
let isTutorSpeaking = false;

const callBtn = document.getElementById('callBtn');
const statusText = document.getElementById('statusText');
const errorText = document.getElementById('errorText');
const callTimer = document.getElementById('callTimer');
const volumeBar = document.getElementById('volumeBar');
const speakingInd = document.getElementById('speakingIndicator');

function showError(msg) {
  errorText.textContent = msg;
  console.error(msg);
}

function clearError() {
  errorText.textContent = '';
}

function setState(s) {
  state = s;
  callBtn.className = s;
  if (s === 'idle') {
    callBtn.textContent = 'üéôÔ∏è';
    statusText.textContent = 'ÌÜµÌôî ÏãúÏûëÏùÑ ÌÉ≠ÌïòÏÑ∏Ïöî / Tap to start';
    speakingInd.classList.remove('visible');
    volumeBar.style.width = '0%';
  } else if (s === 'connecting') {
    callBtn.textContent = '‚è≥';
    statusText.textContent = 'Ïó∞Í≤∞ Ï§ë... / Connecting...';
    clearError();
  } else if (s === 'active') {
    callBtn.textContent = '‚èπÔ∏è';
    setTutorSpeaking(false);
  }
}

function setTutorSpeaking(speaking) {
  isTutorSpeaking = speaking;
  speakingInd.classList.toggle('visible', speaking);
  if (state === 'active') {
    statusText.textContent = speaking ? 'üó£Ô∏è ÌäúÌÑ∞Í∞Ä ÎßêÌïòÎäî Ï§ë... / Tutor speaking...' : 'üé§ ÎãπÏã† Ï∞®Î°Ä! / Your turn!';
  }
}

function updateTimer() {
  const elapsed = Math.floor((Date.now() - callStart) / 1000);
  const m = String(Math.floor(elapsed / 60)).padStart(2, '0');
  const s = String(elapsed % 60).padStart(2, '0');
  callTimer.textContent = `${m}:${s}`;
}

// AudioWorklet processor source (inline)
const captureProcessorCode = `
class CaptureProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this._buf = [];
    this._count = 0;
    this._threshold = 4000;
  }
  process(inputs) {
    const input = inputs[0];
    if (!input || !input[0]) return true;
    const ch = input[0];
    for (let i = 0; i < ch.length; i++) {
      let s = Math.max(-1, Math.min(1, ch[i]));
      this._buf.push(s < 0 ? s * 0x8000 : s * 0x7FFF);
    }
    this._count += ch.length;
    if (this._count >= this._threshold) {
      const pcm = new Int16Array(this._buf);
      this.port.postMessage({ pcm: pcm.buffer }, [pcm.buffer]);
      this._buf = [];
      this._count = 0;
    }
    return true;
  }
}
registerProcessor('capture-processor', CaptureProcessor);
`;

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

let audioSentCount = 0;

function sendAudioChunk(pcmBuffer) {
  if (session && state === 'active') {
    const b64 = arrayBufferToBase64(pcmBuffer);
    try {
      session.sendRealtimeInput({ media: { data: b64, mimeType: 'audio/pcm;rate=16000' } });
      audioSentCount++;
      // Show progress every 4 chunks (~1 second)
      if (audioSentCount % 4 === 0 && !isTutorSpeaking) {
        statusText.textContent = 'üé§ ÎßêÌïòÏÑ∏Ïöî... (' + audioSentCount + ')';
      }
    } catch (err) {
      console.error('sendRealtimeInput error:', err);
      showError('Ï†ÑÏÜ° Ïò§Î•ò: ' + (err.message || err));
    }
    const view = new Int16Array(pcmBuffer);
    let sum = 0;
    for (let i = 0; i < view.length; i++) sum += Math.abs(view[i]);
    const avg = sum / view.length / 32768;
    if (!isTutorSpeaking) volumeBar.style.width = Math.min(100, avg * 400) + '%';
  }
}

let scriptProcessor = null;

async function startMic() {
  micStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true } });
  micContext = new AudioContext({ sampleRate: 16000 });
  const source = micContext.createMediaStreamSource(micStream);

  // Try AudioWorklet first, fall back to ScriptProcessorNode for iOS
  if (micContext.audioWorklet) {
    try {
      const blob = new Blob([captureProcessorCode], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      await micContext.audioWorklet.addModule(url);
      URL.revokeObjectURL(url);
      micWorklet = new AudioWorkletNode(micContext, 'capture-processor');
      micWorklet.port.onmessage = (e) => sendAudioChunk(e.data.pcm);
      source.connect(micWorklet);
      micWorklet.connect(micContext.destination);
      console.log('Mic: AudioWorklet mode');
      return;
    } catch (e) {
      console.warn('AudioWorklet failed, falling back:', e);
    }
  }

  // Fallback: ScriptProcessorNode (works on iOS Chrome/Safari)
  console.log('Mic: ScriptProcessor fallback mode');
  const bufSize = 4096;
  scriptProcessor = micContext.createScriptProcessor(bufSize, 1, 1);
  let pcmBuf = [];
  let sampleCount = 0;
  const threshold = 4000; // ~250ms at 16kHz

  scriptProcessor.onaudioprocess = (e) => {
    const input = e.inputBuffer.getChannelData(0);
    for (let i = 0; i < input.length; i++) {
      let s = Math.max(-1, Math.min(1, input[i]));
      pcmBuf.push(s < 0 ? s * 0x8000 : s * 0x7FFF);
    }
    sampleCount += input.length;
    if (sampleCount >= threshold) {
      const pcm = new Int16Array(pcmBuf);
      sendAudioChunk(pcm.buffer);
      pcmBuf = [];
      sampleCount = 0;
    }
    // Output silence to keep processor alive
    const output = e.outputBuffer.getChannelData(0);
    for (let i = 0; i < output.length; i++) output[i] = 0;
  };

  source.connect(scriptProcessor);
  scriptProcessor.connect(micContext.destination);
}

function stopMic() {
  if (micWorklet) { micWorklet.disconnect(); micWorklet = null; }
  if (scriptProcessor) { scriptProcessor.disconnect(); scriptProcessor = null; }
  if (micContext) { micContext.close(); micContext = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
}

// Seamless audio playback using scheduled timing
let nextPlayTime = 0;
let playAnalyser = null;
let volInterval = null;

function initPlayContext() {
  if (!playContext) {
    playContext = new AudioContext({ sampleRate: 24000 });
    gainNode = playContext.createGain();
    gainNode.gain.value = document.getElementById('volumeSlider').value / 100;
    playAnalyser = playContext.createAnalyser();
    playAnalyser.fftSize = 256;
    gainNode.connect(playAnalyser);
    playAnalyser.connect(playContext.destination);

    // Volume bar updater
    const dataArr = new Uint8Array(playAnalyser.frequencyBinCount);
    volInterval = setInterval(() => {
      if (!isTutorSpeaking) return;
      playAnalyser.getByteFrequencyData(dataArr);
      let sum = 0;
      for (let i = 0; i < dataArr.length; i++) sum += dataArr[i];
      const avg = sum / dataArr.length / 255;
      volumeBar.style.width = Math.min(100, avg * 300) + '%';
    }, 50);
  }
}

function scheduleAudioChunk(pcmBuf) {
  initPlayContext();
  if (playContext.state === 'suspended') playContext.resume();

  const int16 = new Int16Array(pcmBuf);
  const float32 = new Float32Array(int16.length);
  for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

  const audioBuffer = playContext.createBuffer(1, float32.length, 24000);
  audioBuffer.getChannelData(0).set(float32);
  const source = playContext.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(gainNode);

  const now = playContext.currentTime;
  const startTime = Math.max(now, nextPlayTime);
  source.start(startTime);
  nextPlayTime = startTime + audioBuffer.duration;

  // Track when playback finishes
  source.onended = () => {
    if (playContext && playContext.currentTime >= nextPlayTime - 0.05) {
      setTutorSpeaking(false);
      volumeBar.style.width = '0%';
    }
  };

  if (!isTutorSpeaking) setTutorSpeaking(true);
}

function stopPlayback() {
  nextPlayTime = 0;
  if (playContext) {
    playContext.close();
    playContext = null;
    gainNode = null;
    playAnalyser = null;
  }
  if (volInterval) { clearInterval(volInterval); volInterval = null; }
  setTutorSpeaking(false);
  volumeBar.style.width = '0%';
}

async function connectSession() {
  setState('connecting');
  clearError();

  try {
    session = await ai.live.connect({
      model: 'gemini-2.5-flash-native-audio-latest',
      config: {
        responseModalities: ['AUDIO'],
        speechConfig: {
          voiceConfig: {
            prebuiltVoiceConfig: { voiceName: 'Kore' }
          }
        }
      },
      systemInstruction: `You are an expert English conversation tutor for Korean speakers. Your teaching style:

1. CORRECTION FIRST: After the user speaks, ALWAYS point out any grammar, pronunciation, or word choice errors. Say something like "Good try! But instead of '...', you should say '...' because..."
2. PROVIDE THE CORRECT VERSION: Repeat the corrected sentence clearly so the user can hear the proper form.
3. EXPLAIN BRIEFLY: Give a short explanation of WHY it's wrong (grammar rule, natural expression, etc.)
4. ENCOURAGE PRACTICE: Ask the user to repeat the corrected version.
5. THEN CONTINUE: After correction, continue the conversation naturally.

If the user speaks Korean, respond: "Let's try that in English! How would you say that?" and help them translate.

Keep your responses concise (2-3 sentences max per turn). Be warm and encouraging but ALWAYS correct mistakes - that's your primary job. Use simple vocabulary appropriate for intermediate learners.

Start the conversation by greeting the user and asking a simple question to get them talking.`,
      callbacks: {
        onmessage: (msg) => {
          try {
            // Setup complete
            if (msg.setupComplete !== undefined) {
              console.log('Setup complete');
              return;
            }

            // Audio data from server
            if (msg.serverContent) {
              const sc = msg.serverContent;
              if (sc.modelTurn && sc.modelTurn.parts) {
                for (const part of sc.modelTurn.parts) {
                if (part.inlineData && part.inlineData.data) {
                  const pcm = base64ToArrayBuffer(part.inlineData.data);
                  scheduleAudioChunk(pcm);
                }
              }
            }
            if (sc.turnComplete) {
              // Turn done ‚Äî audio queue will finish playing
              console.log('Turn complete');
            }
          }
          } catch (msgErr) {
            console.error('Message handler error:', msgErr);
            showError('Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò');
          }
        },
        onclose: (e) => {
          const reason = e?.reason || e?.code || JSON.stringify(e) || 'unknown';
          console.log('Session closed:', reason);
          if (state === 'active' || state === 'connecting') {
            showError('Ïó∞Í≤∞ Ï¢ÖÎ£å: ' + reason);
            setTimeout(() => endCall(), 2000);
          }
        },
        onerror: (e) => {
          const errMsg = e?.message || e?.error || JSON.stringify(e) || 'unknown';
          console.error('Session error:', errMsg);
          showError('Ïò§Î•ò: ' + errMsg);
          setTimeout(() => endCall(), 2000);
        }
      }
    });

    // Session connected, start mic
    statusText.textContent = 'ÎßàÏù¥ÌÅ¨ Ïó∞Í≤∞ Ï§ë... / Starting mic...';
    try {
      await startMic();
      setState('active');
      audioSentCount = 0;
      callStart = Date.now();
      timerInterval = setInterval(updateTimer, 1000);
      requestWakeLock();
      startNoSleep();
      startKeepAlive();
    } catch (micErr) {
      console.error('Mic error:', micErr);
      showError('ÎßàÏù¥ÌÅ¨ Ïò§Î•ò / Mic error: ' + micErr.message);
      endCall();
    }

  } catch (err) {
    console.error('Connect error:', err);
    showError('Ïó∞Í≤∞ Ïã§Ìå® / Connection failed: ' + (err.message || err));
    setState('idle');
  }
}

// === Wake Lock & Keep-Alive ===
let wakeLock = null;
let keepAliveInterval = null;

async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => { wakeLock = null; });
      console.log('Wake lock acquired');
    }
  } catch (e) { console.log('Wake lock not available:', e); }
}

function releaseWakeLock() {
  if (wakeLock) { wakeLock.release(); wakeLock = null; }
}

// NoSleep fallback for iOS: play silent audio to prevent suspension
let noSleepAudio = null;
function startNoSleep() {
  if (noSleepAudio) return;
  noSleepAudio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
  noSleepAudio.loop = true;
  noSleepAudio.volume = 0.001;
  noSleepAudio.play().catch(() => {});
}
function stopNoSleep() {
  if (noSleepAudio) { noSleepAudio.pause(); noSleepAudio = null; }
}

// Resume AudioContext if iOS suspends it
function startKeepAlive() {
  keepAliveInterval = setInterval(() => {
    if (micContext && micContext.state === 'suspended') {
      micContext.resume();
      console.log('Resumed mic AudioContext');
    }
    if (playContext && playContext.state === 'suspended') {
      playContext.resume();
      console.log('Resumed play AudioContext');
    }
  }, 3000);
}

function stopKeepAlive() {
  if (keepAliveInterval) { clearInterval(keepAliveInterval); keepAliveInterval = null; }
}

// Re-acquire wake lock when page becomes visible again
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && state === 'active') {
    requestWakeLock();
    if (micContext && micContext.state === 'suspended') micContext.resume();
    if (playContext && playContext.state === 'suspended') playContext.resume();
  }
});

function endCall() {
  if (session) {
    try { session.close(); } catch (e) { /* ignore */ }
    session = null;
  }
  stopMic();
  stopPlayback();
  stopKeepAlive();
  stopNoSleep();
  releaseWakeLock();
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  setState('idle');
  callTimer.textContent = '00:00';
}

function toggleCall() {
  if (state === 'idle') {
    connectSession();
  } else {
    endCall();
  }
}

// Volume slider
document.getElementById('volumeSlider').addEventListener('input', (e) => {
  const vol = e.target.value / 100;
  if (gainNode) gainNode.gain.setValueAtTime(vol, playContext.currentTime);
});

// Expose to global for onclick handler
window.toggleCall = toggleCall;

// Telegram WebApp expand
try { if (window.Telegram && Telegram.WebApp) Telegram.WebApp.expand(); } catch(e) {}
</script>
</body>
</html>
