<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>English Tutor | ÏòÅÏñ¥ ÌäúÌÑ∞</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  /* Hide Vapi default widget */
  #vapi-support-btn, .vapi-btn, [id^="vapi"] { display: none !important; }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    height: 100vh; height: 100dvh;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .screen { display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; padding: 20px; }
  .screen.active { display: flex; }

  /* Lock Screen */
  #lockScreen { gap: 24px; }
  .lock-icon { font-size: 64px; margin-bottom: 8px; }
  .lock-title { font-size: 20px; font-weight: 600; color: #fff; }
  .lock-subtitle { font-size: 13px; color: #888; margin-top: -12px; }
  .pin-dots { display: flex; gap: 12px; margin: 8px 0; }
  .pin-dot {
    width: 14px; height: 14px; border-radius: 50%;
    border: 2px solid #555; background: transparent;
    transition: all 0.2s;
  }
  .pin-dot.filled { background: #00c896; border-color: #00c896; }
  .pin-dot.error { border-color: #ff4757; background: #ff4757; }
  .numpad { display: grid; grid-template-columns: repeat(3, 72px); gap: 12px; }
  .numpad button {
    width: 72px; height: 72px; border-radius: 50%;
    border: 1.5px solid #444; background: rgba(255,255,255,0.05);
    color: #fff; font-size: 28px; font-weight: 300;
    cursor: pointer; transition: all 0.15s;
    display: flex; align-items: center; justify-content: center;
  }
  .numpad button:active { background: rgba(0,200,150,0.3); border-color: #00c896; transform: scale(0.93); }
  .numpad button.fn { font-size: 14px; border: none; background: transparent; color: #888; }
  .numpad button.fn:active { color: #fff; }

  /* Call Screen */
  #callScreen { gap: 16px; position: relative; }
  .tutor-avatar {
    width: 120px; height: 120px; border-radius: 50%;
    background: linear-gradient(135deg, #00c896, #00a67e);
    display: flex; align-items: center; justify-content: center;
    font-size: 56px; margin-bottom: 4px;
    box-shadow: 0 0 40px rgba(0,200,150,0.15);
  }
  .tutor-name { font-size: 22px; font-weight: 600; color: #fff; }
  .tutor-label { font-size: 13px; color: #888; }
  #callTimer { font-size: 40px; font-weight: 200; color: #fff; letter-spacing: 2px; font-variant-numeric: tabular-nums; }
  #statusText { font-size: 15px; color: #00c896; min-height: 22px; transition: all 0.3s; }

  .volume-bar-container {
    width: 200px; height: 6px; background: #2a2a4a; border-radius: 3px; overflow: hidden; margin: 4px 0;
  }
  #volumeBar { height: 100%; width: 0%; background: linear-gradient(90deg, #00c896, #00ffaa); border-radius: 3px; transition: width 0.1s; }

  .call-controls { display: flex; gap: 32px; margin-top: 20px; align-items: center; }
  #callBtn {
    width: 80px; height: 80px; border-radius: 50%; border: none;
    font-size: 36px; cursor: pointer; transition: all 0.3s;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  #callBtn.idle { background: #00c896; color: #fff; box-shadow: 0 0 20px rgba(0,200,150,0.4); }
  #callBtn.idle:active { transform: scale(0.92); }
  #callBtn.connecting {
    background: #f39c12; color: #fff;
    animation: pulse-orange 1.2s infinite;
  }
  #callBtn.active {
    background: #ff4757; color: #fff;
    box-shadow: 0 0 25px rgba(255,71,87,0.5);
  }
  #callBtn.active:active { transform: scale(0.92); }

  @keyframes pulse-orange {
    0%, 100% { box-shadow: 0 0 10px rgba(243,156,18,0.4); }
    50% { box-shadow: 0 0 30px rgba(243,156,18,0.7); }
  }

  .speaking-indicator {
    display: none; gap: 3px; align-items: center; height: 30px;
  }
  .speaking-indicator.visible { display: flex; }
  .speaking-indicator .bar {
    width: 4px; border-radius: 2px; background: #00c896;
    animation: speak-bar 0.8s ease-in-out infinite;
  }
  .speaking-indicator .bar:nth-child(1) { height: 10px; animation-delay: 0s; }
  .speaking-indicator .bar:nth-child(2) { height: 20px; animation-delay: 0.15s; }
  .speaking-indicator .bar:nth-child(3) { height: 14px; animation-delay: 0.3s; }
  .speaking-indicator .bar:nth-child(4) { height: 24px; animation-delay: 0.1s; }
  .speaking-indicator .bar:nth-child(5) { height: 12px; animation-delay: 0.25s; }

  @keyframes speak-bar {
    0%, 100% { transform: scaleY(0.4); }
    50% { transform: scaleY(1); }
  }
</style>
</head>
<body>

<!-- Lock Screen -->
<div id="lockScreen" class="screen active">
  <div class="lock-icon">üîí</div>
  <div class="lock-title">English Tutor</div>
  <div class="lock-subtitle">ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî</div>
  <div class="pin-dots" id="pinDots">
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
  </div>
  <div class="numpad" id="numpad">
    <button onclick="pinInput('1')">1</button>
    <button onclick="pinInput('2')">2</button>
    <button onclick="pinInput('3')">3</button>
    <button onclick="pinInput('4')">4</button>
    <button onclick="pinInput('5')">5</button>
    <button onclick="pinInput('6')">6</button>
    <button onclick="pinInput('7')">7</button>
    <button onclick="pinInput('8')">8</button>
    <button onclick="pinInput('9')">9</button>
    <button class="fn"></button>
    <button onclick="pinInput('0')">0</button>
    <button class="fn" onclick="pinDelete()">‚å´</button>
  </div>
</div>

<!-- Call Screen -->
<div id="callScreen" class="screen">
  <div class="tutor-avatar">üéì</div>
  <div class="tutor-name">English Tutor</div>
  <div class="tutor-label">AI ÏòÅÏñ¥ ÌöåÌôî ÌäúÌÑ∞</div>
  <div id="callTimer">00:00</div>
  <div id="statusText">ÌÜµÌôî ÏãúÏûëÏùÑ ÌÉ≠ÌïòÏÑ∏Ïöî / Tap to start</div>
  <div class="volume-bar-container"><div id="volumeBar"></div></div>
  <div class="speaking-indicator" id="speakingIndicator">
    <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
  </div>
  <div class="call-controls">
    <button id="callBtn" class="idle" onclick="toggleCall()">üéôÔ∏è</button>
  </div>
</div>

<script>
// === PIN Lock ===
const PIN_HASH = 'ed7841674a6a92708eed1416db6206916811b10d3375a571ce2eb7139457e98f';
let pinValue = '';

async function sha256(str) {
  const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function updateDots() {
  document.querySelectorAll('.pin-dot').forEach((d, i) => {
    d.classList.toggle('filled', i < pinValue.length);
    d.classList.remove('error');
  });
}

async function pinInput(n) {
  if (pinValue.length >= 6) return;
  pinValue += n;
  updateDots();
  if (pinValue.length === 6) {
    const hash = await sha256(pinValue);
    if (hash === PIN_HASH) {
      document.getElementById('lockScreen').classList.remove('active');
      document.getElementById('callScreen').classList.add('active');
    } else {
      document.querySelectorAll('.pin-dot').forEach(d => d.classList.add('error'));
      setTimeout(() => { pinValue = ''; updateDots(); }, 600);
    }
  }
}

function pinDelete() {
  if (pinValue.length > 0) { pinValue = pinValue.slice(0, -1); updateDots(); }
}

// === Gemini Live API ===
const API_KEY = 'AIzaSyBkCiTO3ZAmqU2nyE9lRVgOvnDcKl8MfoA';
const WS_URL = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1beta.GenerativeService.BidiGenerateContent?key=${API_KEY}`;
const MODEL = 'models/gemini-2.5-flash-native-audio-latest';

let ws = null;
let state = 'idle'; // idle | connecting | active
let micStream = null;
let micContext = null;
let micWorklet = null;
let playContext = null;
let timerInterval = null;
let callStart = 0;
let audioQueue = [];
let isPlaying = false;
let isTutorSpeaking = false;

const callBtn = document.getElementById('callBtn');
const statusText = document.getElementById('statusText');
const callTimer = document.getElementById('callTimer');
const volumeBar = document.getElementById('volumeBar');
const speakingInd = document.getElementById('speakingIndicator');

function setState(s) {
  state = s;
  callBtn.className = s;
  if (s === 'idle') {
    callBtn.textContent = 'üéôÔ∏è';
    statusText.textContent = 'ÌÜµÌôî ÏãúÏûëÏùÑ ÌÉ≠ÌïòÏÑ∏Ïöî / Tap to start';
    speakingInd.classList.remove('visible');
    volumeBar.style.width = '0%';
  } else if (s === 'connecting') {
    callBtn.textContent = '‚è≥';
    statusText.textContent = 'Ïó∞Í≤∞ Ï§ë... / Connecting...';
  } else if (s === 'active') {
    callBtn.textContent = '‚èπÔ∏è';
    setTutorSpeaking(false);
  }
}

function setTutorSpeaking(speaking) {
  isTutorSpeaking = speaking;
  speakingInd.classList.toggle('visible', speaking);
  if (state === 'active') {
    statusText.textContent = speaking ? 'üó£Ô∏è ÌäúÌÑ∞Í∞Ä ÎßêÌïòÎäî Ï§ë... / Tutor speaking...' : 'üé§ ÎãπÏã† Ï∞®Î°Ä! / Your turn!';
  }
}

function updateTimer() {
  const elapsed = Math.floor((Date.now() - callStart) / 1000);
  const m = String(Math.floor(elapsed / 60)).padStart(2, '0');
  const s = String(elapsed % 60).padStart(2, '0');
  callTimer.textContent = `${m}:${s}`;
}

// AudioWorklet processor source (inline)
const captureProcessorCode = `
class CaptureProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this._buf = [];
    this._count = 0;
    // ~250ms at 16kHz = 4000 samples
    this._threshold = 4000;
  }
  process(inputs) {
    const input = inputs[0];
    if (!input || !input[0]) return true;
    const ch = input[0];
    for (let i = 0; i < ch.length; i++) {
      // float32 -> int16
      let s = Math.max(-1, Math.min(1, ch[i]));
      this._buf.push(s < 0 ? s * 0x8000 : s * 0x7FFF);
    }
    this._count += ch.length;
    if (this._count >= this._threshold) {
      const pcm = new Int16Array(this._buf);
      this.port.postMessage({ pcm: pcm.buffer }, [pcm.buffer]);
      this._buf = [];
      this._count = 0;
    }
    return true;
  }
}
registerProcessor('capture-processor', CaptureProcessor);
`;

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

async function startMic() {
  micStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true } });
  micContext = new AudioContext({ sampleRate: 16000 });
  const blob = new Blob([captureProcessorCode], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  await micContext.audioWorklet.addModule(url);
  URL.revokeObjectURL(url);
  const source = micContext.createMediaStreamSource(micStream);
  micWorklet = new AudioWorkletNode(micContext, 'capture-processor');
  micWorklet.port.onmessage = (e) => {
    if (ws && ws.readyState === WebSocket.OPEN && state === 'active') {
      const b64 = arrayBufferToBase64(e.data.pcm);
      ws.send(JSON.stringify({
        realtime_input: {
          media_chunks: [{ data: b64, mime_type: 'audio/pcm;rate=16000' }]
        }
      }));
      // Update volume bar from PCM
      const view = new Int16Array(e.data.pcm);
      let sum = 0;
      for (let i = 0; i < view.length; i++) sum += Math.abs(view[i]);
      const avg = sum / view.length / 32768;
      if (!isTutorSpeaking) volumeBar.style.width = Math.min(100, avg * 400) + '%';
    }
  };
  source.connect(micWorklet);
  micWorklet.connect(micContext.destination); // needed to keep worklet alive
}

function stopMic() {
  if (micWorklet) { micWorklet.disconnect(); micWorklet = null; }
  if (micContext) { micContext.close(); micContext = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
}

async function playAudioQueue() {
  if (isPlaying || audioQueue.length === 0) return;
  isPlaying = true;
  setTutorSpeaking(true);

  if (!playContext) playContext = new AudioContext({ sampleRate: 24000 });
  if (playContext.state === 'suspended') await playContext.resume();

  while (audioQueue.length > 0) {
    const pcmBuf = audioQueue.shift();
    const int16 = new Int16Array(pcmBuf);
    const float32 = new Float32Array(int16.length);
    for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768;

    const audioBuffer = playContext.createBuffer(1, float32.length, 24000);
    audioBuffer.getChannelData(0).set(float32);
    const source = playContext.createBufferSource();
    source.buffer = audioBuffer;

    // Analyser for volume
    const analyser = playContext.createAnalyser();
    analyser.fftSize = 256;
    source.connect(analyser);
    analyser.connect(playContext.destination);

    const dataArr = new Uint8Array(analyser.frequencyBinCount);
    const volInterval = setInterval(() => {
      analyser.getByteFrequencyData(dataArr);
      let sum = 0;
      for (let i = 0; i < dataArr.length; i++) sum += dataArr[i];
      const avg = sum / dataArr.length / 255;
      volumeBar.style.width = Math.min(100, avg * 300) + '%';
    }, 50);

    await new Promise(resolve => {
      source.onended = () => { clearInterval(volInterval); resolve(); };
      source.start();
    });
  }

  isPlaying = false;
  setTutorSpeaking(false);
  volumeBar.style.width = '0%';
}

function connectWS() {
  setState('connecting');
  try {
    ws = new WebSocket(WS_URL);
  } catch(e) {
    statusText.textContent = '‚ùå WebSocket ÏÉùÏÑ± Ïã§Ìå®: ' + e.message;
    setState('idle');
    return;
  }

  ws.onopen = () => {
    console.log('WS connected, sending setup...');
    statusText.textContent = 'ÏÑ§Ï†ï Ï§ë... / Setting up...';
    ws.send(JSON.stringify({
      setup: {
        model: MODEL,
        generation_config: {
          response_modalities: ['AUDIO'],
          speech_config: {
            voice_config: {
              prebuilt_voice_config: { voice_name: 'Kore' }
            }
          }
        },
        system_instruction: {
          parts: [{
            text: 'You are a friendly English conversation tutor. Help the user practice English conversation naturally. Speak in simple, clear English. If the user speaks Korean, gently guide them to try in English. Give encouragement and corrections when needed. Keep conversations casual and fun.'
          }]
        }
      }
    }));
  };

  ws.onmessage = async (event) => {
    try {
      const msg = JSON.parse(event.data);
      console.log('WS msg keys:', Object.keys(msg));

      // Setup complete
      if (msg.setupComplete !== undefined) {
        console.log('Setup complete, starting mic...');
        statusText.textContent = 'ÎßàÏù¥ÌÅ¨ Ïó∞Í≤∞ Ï§ë... / Starting mic...';
        try {
          await startMic();
          setState('active');
          callStart = Date.now();
          timerInterval = setInterval(updateTimer, 1000);
        } catch (micErr) {
          console.error('Mic error:', micErr);
          statusText.textContent = '‚ùå ÎßàÏù¥ÌÅ¨ Ïò§Î•ò: ' + micErr.message;
          endCall();
        }
        return;
      }

      // Audio data from server
      if (msg.serverContent) {
        const sc = msg.serverContent;
        if (sc.modelTurn && sc.modelTurn.parts) {
          for (const part of sc.modelTurn.parts) {
            if (part.inlineData && part.inlineData.data) {
              const pcm = base64ToArrayBuffer(part.inlineData.data);
              audioQueue.push(pcm);
              playAudioQueue();
            }
          }
        }
        if (sc.turnComplete) {
          // Turn done ‚Äî audio queue will finish playing
        }
      }
    } catch (e) {
      console.error('WS message parse error:', e);
    }
  };

  ws.onerror = (e) => {
    console.error('WS error', e);
    statusText.textContent = '‚ùå Ïó∞Í≤∞ Ïò§Î•ò / Connection error';
    setTimeout(() => endCall(), 2000);
  };

  ws.onclose = (e) => {
    console.log('WS closed:', e.code, e.reason);
    if (state === 'active' || state === 'connecting') {
      statusText.textContent = 'Ïó∞Í≤∞ Ï¢ÖÎ£åÎê® / Disconnected';
      setTimeout(() => endCall(), 1500);
    }
  };
}

function endCall() {
  if (ws) { ws.close(); ws = null; }
  stopMic();
  if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
  audioQueue = [];
  isPlaying = false;
  setState('idle');
  callTimer.textContent = '00:00';
}

function toggleCall() {
  if (state === 'idle') {
    connectWS();
  } else {
    endCall();
  }
}

// Telegram WebApp expand
try { if (window.Telegram && Telegram.WebApp) Telegram.WebApp.expand(); } catch(e) {}
</script>
</body>
</html>
